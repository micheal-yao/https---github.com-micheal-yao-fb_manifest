// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MANIFEST_H_
#define FLATBUFFERS_GENERATED_MANIFEST_H_

#include "flatbuffers/flatbuffers.h"

struct AssetData;

struct ManifestData;

enum DownloadState {
  DownloadState_Unknown = 0,
  DownloadState_Unstarted = 1,
  DownloadState_Downloading = 2,
  DownloadState_Successed = 3,
  DownloadState_MIN = DownloadState_Unknown,
  DownloadState_MAX = DownloadState_Successed
};

inline DownloadState (&EnumValuesDownloadState())[4] {
  static DownloadState values[] = {
    DownloadState_Unknown,
    DownloadState_Unstarted,
    DownloadState_Downloading,
    DownloadState_Successed
  };
  return values;
}

inline const char **EnumNamesDownloadState() {
  static const char *names[] = {
    "Unknown",
    "Unstarted",
    "Downloading",
    "Successed",
    nullptr
  };
  return names;
}

inline const char *EnumNameDownloadState(DownloadState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDownloadState()[index];
}

struct AssetData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_CRC32 = 6,
    VT_SIZE = 8,
    VT_COMPRESSED = 10,
    VT_STATE = 12
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool KeyCompareLessThan(const AssetData *o) const {
    return *path() < *o->path();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(path()->c_str(), val);
  }
  uint32_t crc32() const {
    return GetField<uint32_t>(VT_CRC32, 0);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  bool compressed() const {
    return GetField<uint8_t>(VT_COMPRESSED, 0) != 0;
  }
  DownloadState state() const {
    return static_cast<DownloadState>(GetField<int8_t>(VT_STATE, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<uint32_t>(verifier, VT_CRC32) &&
           VerifyField<float>(verifier, VT_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSED) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct AssetDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(AssetData::VT_PATH, path);
  }
  void add_crc32(uint32_t crc32) {
    fbb_.AddElement<uint32_t>(AssetData::VT_CRC32, crc32, 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(AssetData::VT_SIZE, size, 0.0f);
  }
  void add_compressed(bool compressed) {
    fbb_.AddElement<uint8_t>(AssetData::VT_COMPRESSED, static_cast<uint8_t>(compressed), 0);
  }
  void add_state(DownloadState state) {
    fbb_.AddElement<int8_t>(AssetData::VT_STATE, static_cast<int8_t>(state), 1);
  }
  explicit AssetDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetDataBuilder &operator=(const AssetDataBuilder &);
  flatbuffers::Offset<AssetData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetData>(end);
    fbb_.Required(o, AssetData::VT_PATH);
    return o;
  }
};

inline flatbuffers::Offset<AssetData> CreateAssetData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    uint32_t crc32 = 0,
    float size = 0.0f,
    bool compressed = false,
    DownloadState state = DownloadState_Unstarted) {
  AssetDataBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_crc32(crc32);
  builder_.add_path(path);
  builder_.add_state(state);
  builder_.add_compressed(compressed);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetData> CreateAssetDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    uint32_t crc32 = 0,
    float size = 0.0f,
    bool compressed = false,
    DownloadState state = DownloadState_Unstarted) {
  return CreateAssetData(
      _fbb,
      path ? _fbb.CreateString(path) : 0,
      crc32,
      size,
      compressed,
      state);
}

struct ManifestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_APPVERSION = 4,
    VT_RESOURCEVERSION = 6,
    VT_ASSETS = 8
  };
  const flatbuffers::String *appVersion() const {
    return GetPointer<const flatbuffers::String *>(VT_APPVERSION);
  }
  const flatbuffers::String *resourceVersion() const {
    return GetPointer<const flatbuffers::String *>(VT_RESOURCEVERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AssetData>> *assets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AssetData>> *>(VT_ASSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APPVERSION) &&
           verifier.Verify(appVersion()) &&
           VerifyOffset(verifier, VT_RESOURCEVERSION) &&
           verifier.Verify(resourceVersion()) &&
           VerifyOffset(verifier, VT_ASSETS) &&
           verifier.Verify(assets()) &&
           verifier.VerifyVectorOfTables(assets()) &&
           verifier.EndTable();
  }
};

struct ManifestDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_appVersion(flatbuffers::Offset<flatbuffers::String> appVersion) {
    fbb_.AddOffset(ManifestData::VT_APPVERSION, appVersion);
  }
  void add_resourceVersion(flatbuffers::Offset<flatbuffers::String> resourceVersion) {
    fbb_.AddOffset(ManifestData::VT_RESOURCEVERSION, resourceVersion);
  }
  void add_assets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AssetData>>> assets) {
    fbb_.AddOffset(ManifestData::VT_ASSETS, assets);
  }
  explicit ManifestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ManifestDataBuilder &operator=(const ManifestDataBuilder &);
  flatbuffers::Offset<ManifestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ManifestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ManifestData> CreateManifestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> appVersion = 0,
    flatbuffers::Offset<flatbuffers::String> resourceVersion = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AssetData>>> assets = 0) {
  ManifestDataBuilder builder_(_fbb);
  builder_.add_assets(assets);
  builder_.add_resourceVersion(resourceVersion);
  builder_.add_appVersion(appVersion);
  return builder_.Finish();
}

inline flatbuffers::Offset<ManifestData> CreateManifestDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *appVersion = nullptr,
    const char *resourceVersion = nullptr,
    const std::vector<flatbuffers::Offset<AssetData>> *assets = nullptr) {
  return CreateManifestData(
      _fbb,
      appVersion ? _fbb.CreateString(appVersion) : 0,
      resourceVersion ? _fbb.CreateString(resourceVersion) : 0,
      assets ? _fbb.CreateVector<flatbuffers::Offset<AssetData>>(*assets) : 0);
}

inline const ManifestData *GetManifestData(const void *buf) {
  return flatbuffers::GetRoot<ManifestData>(buf);
}

inline bool VerifyManifestDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ManifestData>(nullptr);
}

inline void FinishManifestDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ManifestData> root) {
  fbb.Finish(root);
}

#endif  // FLATBUFFERS_GENERATED_MANIFEST_H_
